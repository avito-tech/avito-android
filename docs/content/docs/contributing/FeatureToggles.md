---
title: Feature toggle
type: docs
---

# Feature toggle

{{<avito page>}}

- [Feature toggle (Wikipedia)](https://en.wikipedia.org/wiki/Feature_toggle)
- [Feature toggle (Martin Fowler)](https://martinfowler.com/bliki/FeatureToggle.html)
- [Feature Toggles (Pete Hodgson)](https://martinfowler.com/articles/feature-toggles.html)

Используется для уменьшения рисков при внедрении новой функциональности. Позволяет: 

- Не держать изменения в отдельной ветке до окончания тестирования
- Отключить на этапе стабилизации, во время регрессионного тестирования

## Cоздание

Решение о создании feature toggle принимается на основе различных критериев:

- Изолированность изменений, насколько легко их отключить
- Риск привнести нестабильность

## Реализация

- По умолчанию непротестированная логика должна быть отключена
- Отключать необходимо самым дешевым и надежным способом, с минимальным влиянием на логику
- Важно не сломать существующую логику, с отключенным feature toggle, т.к. это уже нельзя отключить

### Отделение точки принятия решения от логики

Feature toggle - это детали реализации, подверженные изменениям. 
При принятии решений в логике необходимо оперировать подходящим уровнем абстракции.

Обычно хватает выделения этих знаний в функцию.

```kotlin

fun shouldUseSessionInParameters() = not(features.sessionInHeader())

```

### Инверсия решений

Чтобы убрать из логики знания про реализацию, иногда дешевле переключать всю реализацию целиком:

```kotlin

@Provides
CommonChannelsInteractor provideInteractor(...) {
    return if (features.webSocketMessengerEnabled()) {
        MessengerCommonChannelsInteractorImpl(...)
    } else {
        ApiCommonChannelsInteractor(...)
    }
}

```

## Тестирование

### Юнит тесты

Для того, чтобы выявить все непредвиденные использования переключателей, не задаем никакого состояния по умолчанию. Это вынудит в тесте явно перебрать все состояния.

```kotlin

@Mock private lateinit var features: Features

```

### Компонентные и функциональные тесты

В таких тестах нет возможности изоляции логики и по умолчанию используем релизное состояние переключателей. 
Это компромиссный вариант, в котором делаем акцент на выявлении регрессии, а не на формальной проверке всех возможных состояний. Проверка всех состояний других фич не целесообразна.

Необходимы, как минимум, два набора тестов:

- Проверка регресса, старого поведения. Новая фича отключена, все остальные в состоянии по умолчанию.
- Проверка нового поведения. Новая фича включена, все остальные в состоянии по умолчанию.

## Удаление

Необходимо обязательно избавляться от устаревших переключателей. Но делать это можно только после того, как убедимся в работоспособности и стабильности решения.
Исходя из целей, рекомендуется удалять после feature freeze.
